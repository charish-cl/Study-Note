# 帧同步

## 原理简介

A.什么是帧同步？
帧同步是一种前后端数据同步的方式，一般应用于对实时性要求很高的网络游戏。

其基本实现流程及思路可以概括为:

1.所有客户端每帧上传操作指令集到服务器;
2.服务端将这些操作指令集保存到对应帧序列字典，并记录帧号，并在下一帧将其广播给所有客户端;
3.客户端收到指令集后，分别按帧序，帧号进行执行指令集中的操作命令。
4.也就是：相同的时机(帧序列) + 相同的操作命令(指令集-确定性) = 相同的结果(帧同步)

- 相同输入,相同输出
- 逻辑帧,服务器推动客户端,保证客户端都从第一帧开始
- 浮点型,多线程 不建议使用

## **解决方案内容**

### 1.0 帧锁步[Lockstep]

a.什么是帧锁步？
当客户端A存在网络延迟导致服务器第X帧收集不到A的第X帧输入指令包时，
服务器就需要等待所有客户端的X帧指令收集完成，才会下发X帧的所有客户端包数据以此保持同步，
也就意味着一人延迟，所有客户端都得等，显然这种同步概念不太适用于竞技性比较高的游戏，玩家体验会很差。

### 2.0 乐观帧

a.什么是乐观帧？
其他乐观帧是在帧锁步的基础上进行改良，为了提高游戏体验，服务器不再要求必须收集所有客户端X帧的操作指令才进行分发，
而是每个客户端都进行本地输入指令快照存储，存储各自的输入指令(并带有帧号)。
如果A客户端因为延迟从第2帧(逻辑帧)开始丢包直到第5帧传输正常，那么服务器即使收不到A客户端2-5帧的输入指令还是继续分发，
直到第5帧再将A客户端2-5帧的本地快照一并分发出去，同时将其他客户端2-5帧的输入指令同步到本地客户端，当然丢失3帧的数据直接在一帧同步
到客户端会导致卡顿瞬移，所以A客户端需要进行加速操作执行指令操作，通常会做差值计算，通过补间动画的方式让同步更平滑。

### 预测回滚

每个客户端按照帧同步的方案推进着游戏，但是如果遇到服务器没能及时返回其他玩家操作的时候，给对应的玩家预测一个操作(复制该玩家最后一次操作),并继续推进游戏，如果在其后收到了服务器玩家关于这个人的操作，则把游戏回滚到预测开始的那一帧重新计算一遍。
《守望先锋》便采取了这种模式，获得了很大效率的网络优化。预测回滚核心在于预测写入快照，适当时机进行回滚，然而每一帧都写入快照显然内存会吃紧，同时回滚机制会变得异常复杂。
a.什么是预测回滚？
预测回滚是一种同步机制，是乐观帧的一种解决方案，上面提到的乐观帧有个最大的缺点是一旦A客户端丢包，那么其他客户端的A在丢包期间将不会有任何
操作指令同步,这样会影响游戏体验，所以这里引用预测机制，如果客户端在X帧没有指令数据那么服务器会给它在X帧一个预测的输入指令，当A客户端连接后，
服务器会对预测数据和真实丢失快照数据进行和解，回滚。


原文链接：https://blog.csdn.net/aaa583004321/article/details/104963785

### 3.0 定点数

1.什么是定点数?为什么要使用定点数?

定点数是指在计算机中小数点的位置固定的数。相反小数位数不固定的则是浮点数,例如float,double数据类型，它们属于高精度单双浮点数类型，由于不同机器CPU对浮点数的处理结果会存在偏差，再加之网路延迟影响，由此而带来的蝴蝶效应影响，终会导致不相同的计算结果，导致逻辑不可控，因此为了数据的完全的一致，应采用定点数替代浮点数。

由此我们发现帧同步网络服务器只负责收发指令数据，不进行战斗逻辑的计算。那么由于客户端性能算力不一样，导致浮点数数据类型(float(单),double(双))不再适用，
因为浮点数带有精度，会导致每个客户端的计算结果会存在偏差，从而导致不同步，进而产生蝴蝶效益导致正常战斗完全不同步。所以这里引入定点数。
定点数专为解决浮点数精度差，主要实现方式有两种:

#### a.尾数截断

可以到这里去看看这里帧同步项目的实例,注明:这是早期Photon的TrueSync经过大佬完善后的实例，有参考价值，其中用到就是[尾数截断]实现定点数

#### b.移位运算


左移操作时将运算数的二进制码整体左移指定位数，左移之后的空位用0补充
右移操作是将运算数的二进制码整体右移指定位数，右移之后的空位用符号位补充，如果是正数用0补充，负数用1补充
通过移位操作我们可以消除精度，至于移位数我觉得(16位)已经完全可以满足需求。
注:65536是右移位16的结果
将浮点数右移16位得到一个long类型，long类型赋值给Fixed类型编码,便得到一个定点数。

```cs
var l= (long)unchecked(value * 65536f)
public static Fixed FromRaw(long value)
{
    Fixed r;
    r.RawValue = value;
    return r;
}
```

同样将反向转换只需左移位操作即可:

```cs
public static explicit operator float(Fixed value)
{
return (float)value.RawValue / 65536f;
}
```



# 状态同步

- 客户端先行

- 主要逻辑在服务端

  

